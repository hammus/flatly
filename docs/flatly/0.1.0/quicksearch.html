<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"flatly.js.html":{"id":"flatly.js.html","title":"Source: flatly.js","body":" flatly Classes flatlyio Source: flatly.js /** * @fileOverview * @author Liam Whan * @memberOf core * */ ; (function () { &quot;use strict&quot;; const io = require('./io'); const path = require('path'); const _ = require('lodash'); /** * flatly class contains the entire flatly api * @func flatly * @classdesc flatly is a simple flat file JSON db system. * @class * @constructor * @returns {flatly} */ function flatly() { if (new.target === undefined) { throw &quot;You must instantiate flatly. e.g. const Flatly = require('flatly');\\r\\nvar flatly = new Flatly();&quot; } //region Private members /** * @member _tables Tables collection * @type {Object} * @private */ let _tables = [], /** * @member _files Array of table file names * @type {Array} * @private */ _files, /** * @member _baseDir The base directory where the table files are located. * @type {string} * @private */ _baseDir = &quot;&quot;; /** * Get the flatly metadata * @param obj * @returns {Object|boolean} * @private */ let _getMeta = (obj) =&gt; { if (!_.has(obj, '$$flatly')) { return false; } else { return obj['$$flatly']; } }; /** * Removes flatly metadata before saving to disk * @function flatly~_removeMeta * @param data * @returns {*} * @private */ let _removeMeta = (data) =&gt; { var clone = _.cloneDeep(data); if (_.has(clone, '$$flatly')) { delete clone['$$flatly']; } _.each(clone, (row) =&gt; { if (_.has(row, '$$flatly')) { delete row['$$flatly']; } }); return clone; }; /** * @function flatly~_parseCriteria * @desc Helper method to parse the search criteria object * @private * @param criteria {Object} The criteria object to parse * @param criteria.from {String} Table name * @param criteria.where {Object} An object defining the search criteria * @param criteria.where.column {String} the Column name to search * @param criteria.where.equals {String} the search term. * @returns {Object} The search result object is of form {&quot;columnName&quot;: searchTerm} which is used by the find methods */ function _parseCriteria(criteria) { if (!_.has(criteria, 'from') || !_.has(criteria, 'where') || !_.has(criteria, 'where.column') || !_.has(criteria, 'where.equals') ) { throw new Error('You must include both &quot;where&quot; and &quot;from&quot; criteria to use findOne()'); } let search = {}; search[criteria.where.column.toLowerCase()] = criteria.where.equals; return search; } //endregion // region Public /** * The name of the database currently in use * @member {String} */ this.name = undefined; /** * Returns currently selected database name and table names * * @function flatly#dbInfo * @returns {{name: String, tables: Array, count: number}} An object with the database name, table names and table count */ this.dbInfo = () =&gt; { return { name: this.name, tables: this.getSchema(), count: this.getSchema().length } }; /** * Returns the schema of the currently selected DB * * @function flatly#getSchema * @example console.log(flatly.getSchema()); * // -&gt; ['table1', 'table2', 'table3'] * @returns {string[]} */ this.getSchema = () =&gt; _.keys(_tables); /** * Returns a deep clone of the tables array * * @memberOf flatly * @function flatly#tables * @returns {Array} */ this.tables = () =&gt; _tables; /** * Returns an object representing the table requested. Use {@link flatly#findOne} or {@link flatly#findAll} for querying table contents * * @function flatly#getTable * @param tblName {String} The name of the table to be returned * @returns {Object} An object representing the requested table */ this.getTable = function (tblName) { tblName = tblName.toLowerCase(); return _.cloneDeep(_tables[tblName]); }; /** * Returns a row from the specified table * * @function flatly#findOne * @param {Object} criteria An options object with the search details * @param {String} criteria.from The name of the table to search * @param {Object} criteria.where An object containing the column and value criterion * @params {String} criteria.where.column The name of the column to search * @params {number|String} criteria.where.equals The value to search the column for * @returns {?Array} An array containing the search result */ this.findOne = (criteria) =&gt; { let tblName = criteria.from; let search = _parseCriteria(criteria); let tblTarget = this.getTable(tblName.toLowerCase()); let result = _.find(tblTarget, search); return result || null; }; /** * Returns all rows that match the criteria object * @function flatly#findAll * @param {Object} criteria An options object with the search details * @param {String} criteria.from The name of the table to search * @param {Object} criteria.where An object containing the column and value criterion * @params {String} criteria.where.column The name of the column to search * @params {number|String} criteria.where.equals The value to search the column for * @returns {*} */ this.findAll = (criteria) =&gt; { if (!_.has(criteria, 'from') || !_.has(criteria, 'where') || !_.has(criteria, 'where.column') || !_.has(criteria, 'where.equals') ) { throw new Error('You must include both &quot;where&quot; and &quot;from&quot; criteria to use findAll()'); } let search = {}; search[criteria.where.column] = criteria.where.equals; let result = _.filter(this.getTable(criteria.from), search); return (result) ? [result] : null; }; /** * Loads a database from the specified filepath * * @function flatly#use * @param options {Object} * @param options.name {String} Specify a name for the database * @param options.src {String} A path to the required data * @returns {flatly} */ this.use = function (options) { this.name = options.name.toLowerCase(); _baseDir = path.resolve(global.parent, options.src); _files = io.getAll({src: _baseDir}); /* Add table and row metadata */ let tablesClean = io.parse(options.name, _files); _tables = _addMeta(tablesClean); return this; }; /** * Adds flatly metadata to db object * @param data {Object|Array} the data to tag * @param [tblName] {String} a string identifier for what * @returns {*} * @private */ let _addMeta = (data, tblName) =&gt; { let clone = _.cloneDeep(data); let meta = { $$flatly: { table: tblName } }; if(!_.has(clone, '$$flatly')) { _.forIn(clone, (tbl, tblName) =&gt; { _.forIn(tbl, (row) =&gt; { _.assign(row, meta); }); _.assign(tbl, meta); }); } else { _.assign(clone, meta); } return clone; }; /** * Save table data to disk. Remove flatly metadata before saving. * * @func flatly#save * @param options {Object} * @param options.table {string} The table to save * @param [options.overwrite=false] Overwrite the existing table? * @param [options.async=false] {boolean} Sync/Async Execution. Defaults to Sync * @param [callback] {function} The callback to execute if we're working asynchronously * @returns {flatly} */ this.save = function (options, callback) { if (!_.has(options, 'table')) { throw new Error('You must pass a &quot;table&quot; parameter to use save()'); } _.defaults(options, {overwrite: false}, {async: false}); let target = _removeMeta(this.getTable(options.table)); let filename = options.table; let tblFile = path.normalize(path.format({ dir: _baseDir, base: filename + &quot;.json&quot;, ext: &quot;.json&quot;, name: options.table })); if (_.has(options, 'async') &amp;&amp; options.async) { if (_.isUndefined(callback)) { throw Error(&quot;save() is set to async and no callback was supplied.&quot;); } else { io.put(target, tblFile, callback, options.overwrite); return this; } } else { io.put(target, tblFile, options.overwrite); return this; } }; /** * Returns the a new Id for a table * @func flatly~nextId * @param tblName {Object} The table to query * @private * @returns {number} */ let _nextId = (table) =&gt; { let maxId = _.max(_.map(table, 'id')); return maxId + 1; }; this.checkExists = (tblName, column, value) =&gt; { var bool = this.findOne({from: tblName, where: {column: column, equals: value}}); if(_.isNull(bool)) { return false; } else { return true; } } this.insert = (row, tblName) =&gt; { let table = this.getTable(tblName); if(!_.isNull(table)) { let newId = table.length === 0 ? 1 : _nextId(table); row.id = newId; row = _addMeta(row, 'manifest'); _tables[tblName].push(row); return this; } else { throw Error('Table not found: ', tblName); } }; /** * Update an existing table row * @func flatly#update * @param rowData {Object} An object representing a row of the target table * @param matchBy {String} The key to use to match rowData to an existing row in the table * @param tblName {String} The target table name * @example flatly.update({ * id: 6, * name: Michael Flatly * }, 'id', 'customers'); * @returns {flatly} */ this.update = (rowData, matchBy, tblName) =&gt; { if (_.has(rowData, '$$flatly')) { tblName = rowData.$$flatly.table; } else { if (_.isUndefined(tblName)) { throw new Error(&quot;You must pass a flatly object or the name of the table to insert the data into&quot;); } } if(!_.has(rowData, matchBy)) { throw new Error(&quot;The key: &quot; + matchBy + &quot; does not exist.&quot;); } var where = { column: matchBy, equals: rowData[matchBy] }; var old = this.findOne({from: tblName, where: where}); if(old) { let index = _.findIndex(_tables[tblName], old); if(index !== -1) { _tables[tblName].splice(index, 1, rowData); } else { console.warn(&quot;Could not find the specified Row in table &quot; + tblName); } } else { console.warn(&quot;No object found&quot;, matchBy); } return this; }; //endregion }//end flatly() module.exports = flatly; })(); Ã— Search results Close "},"io.js.html":{"id":"io.js.html","title":"Source: io.js","body":" flatly Classes flatlyio Source: io.js /** * @memberOf core */ (function () { const fs = require('graceful-fs'); const glob = require('glob'); const jph = require('json-parse-helpfulerror'); const parse = jph.parse; const _ = require('lodash'); const path = require('path'); /** * @namespace io * @classdesc Main flatly class used to load db and query data * @constructor * @desc I/O Operations for the flatly library * @class */ function io() { &quot;use strict&quot;; /** * @func io#getAll * @desc Takes a glob pattern and returns an array of table files * @param options {Object} * @param options.src {String} Glob pattern of target files * @param {string} [options.format=JSON] A string switch that tells flatly what format the source files are in * @returns {Array} * @example var files = io.getAll('../data/*.json') */ this.getAll = function (options) { _.defaults(options, {format: 'JSON'}); var pattern = &quot;&quot;; if(options.format !== 'JSON') { //TODO add support for other formats } else { pattern = path.join(options.src, '/**/*.json'); } try { var files = glob.sync(pattern); } catch (e) { if(e.message == 'must provide pattern') { console.error('Theres something wrong with the supplied glob: ', pattern); } } if(files.length == 0) { throw new Error(&quot;No files found at: &quot; + pattern); } return files; }; /** * @desc Parse JSON files into JS objects * @param dbName {String} * @param {String|Array} tables | A string containing the filepaths of the tables * @returns {Object} */ this.parse = function (dbName, tables) { if (!_.isArray(tables)) { tables = [tables]; } var results = {}; tables.forEach(function (item) { var tblName = path.basename(item, path.extname(item)).toLowerCase(); var tblData = parse(fs.readFileSync(item)); results[tblName] = tblData; }); return results; }; /** * Write data to file asynchronously * @param data * @param destination * @param cb */ this.put = (data, destination, cb, overwrite) =&gt; { var stringified = JSON.stringify(data, null, 2); fs.writeFile(destination, stringified, null, cb); }; /** * Write data to file synchronously * @param {Object} data * @param {string} destination * @param {boolean} overwrite * @param {function} callback * @param {boolean} [overwrite=false] Overwrite the existing table file? */ this.putSync = (data, destination, overwrite, callback) =&gt; { let ts = &quot;-&quot; + new Date().getTime().toString(); let dir = path.dirname(destination); var stringified = JSON.stringify(data, null, 2); if(overwrite) { let back = path.join(dir, path.basename(destination, path.extname(destination)) + ts + '.bak'); this.backup(destination, back); } else { let file = path.basename(destination, path.extname(destination)) + ts + '.json'; destination = path.join(dir, file); } if(!_.isUndefined(callback)) { fs.writeFile(destination, stringified, callback); } else { fs.writeFileSync(destination, stringified); } } /** * Create a backup of a file * @param source * @param destination */ this.backup = (source, destination) =&gt; { fs.createReadStream(source).pipe(fs.createWriteStream(destination)); } } module.exports = new io(); })(); Ã— Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" flatly Classes flatlyio Classes Classes flatly io Ã— Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" flatly Classes flatlyio flatly 0.1.0 Index flatly.js Author: Liam Whan Source: flatly.js, line 1 Ã— Search results Close "},"flatly.html":{"id":"flatly.html","title":"Class: flatly","body":" flatly Classes flatlyio Class: flatly flatly flatly is a simple flat file JSON db system. new flatly() flatly class contains the entire flatly api Source: flatly.js, line 18 Returns: Type flatly Methods dbInfo() Returns currently selected database name and table names Source: flatly.js, line 124 Returns: An object with the database name, table names and table count Type Object findAll(criteria) Returns all rows that match the criteria object Parameters: Name Type Description criteria Object An options object with the search details Properties Name Type Description from String The name of the table to search where Object An object containing the column and value criterion Source: flatly.js, line 194 Returns: Type * findOne(criteria) Returns a row from the specified table Parameters: Name Type Description criteria Object An options object with the search details Properties Name Type Description from String The name of the table to search where Object An object containing the column and value criterion Source: flatly.js, line 172 Returns: An array containing the search result Type Array getSchema() Returns the schema of the currently selected DB Source: flatly.js, line 140 Returns: Type Array.&lt;string&gt; Example console.log(flatly.getSchema()); // -&gt; ['table1', 'table2', 'table3'] getTable(tblName) Returns an object representing the table requested. Use flatly#findOne or flatly#findAll for querying table contents Parameters: Name Type Description tblName String The name of the table to be returned Source: flatly.js, line 160 Returns: An object representing the requested table Type Object save(options, callback) Save table data to disk. Remove flatly metadata before saving. Parameters: Name Type Argument Description options Object Properties Name Type Argument Default Description table string The table to save overwrite &lt;optional&gt; false Overwrite the existing table? async boolean &lt;optional&gt; false Sync/Async Execution. Defaults to Sync callback function &lt;optional&gt; The callback to execute if we're working asynchronously Source: flatly.js, line 277 Returns: Type flatly tables() Returns a deep clone of the tables array Source: flatly.js, line 151 Returns: Type Array update(rowData, matchBy, tblName) Update an existing table row Parameters: Name Type Description rowData Object An object representing a row of the target table matchBy String The key to use to match rowData to an existing row in the table tblName String The target table name Source: flatly.js, line 368 Returns: Type flatly Example flatly.update({ id: 6, name: Michael Flatly }, 'id', 'customers'); use(options) Loads a database from the specified filepath Parameters: Name Type Description options Object Properties Name Type Description name String Specify a name for the database src String A path to the required data Source: flatly.js, line 219 Returns: Type flatly Ã— Search results Close "},"io.html":{"id":"io.html","title":"Class: io","body":" flatly Classes flatlyio Class: io io Main flatly class used to load db and query data new io() I/O Operations for the flatly library Source: io.js, line 14 Methods getAll(options) Takes a glob pattern and returns an array of table files Parameters: Name Type Description options Object Properties Name Type Argument Default Description src String Glob pattern of target files format string &lt;optional&gt; JSON A string switch that tells flatly what format the source files are in Source: io.js, line 24 Returns: Type Array Example var files = io.getAll('../data/*.json') Ã— Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
